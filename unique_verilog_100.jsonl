{"user_question": "Write a synthesizable Verilog module implementing a Moore sequence detector that detects the sequence 1010 on a serial input stream. The output should go high when the sequence is detected.", "eval_prompt": "module moore_seq_1010 (\n    input clk,\n    input reset,\n    input in,\n    output reg out\n);\n    reg [2:0] state;\n    parameter S0 = 0;\n    parameter S1 = 1;\n    parameter S2 = 2;\n    parameter S3 = 3;\n    parameter S4 = 4;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) state <= S0;\n        else begin\n            case (state)\n                        S0: state <= (in == 1) ? S1 : S1;\n                        S1: state <= (in == 0) ? S2 : S1;\n                        S2: state <= (in == 1) ? S3 : S1;\n                        S3: state <= (in == 0) ? S4 : S1;\n            default: state <= S0;\n            endcase\n        end\n    end\n\n    assign out = (state == S4) ? 1'b1 : 1'b0;\nendmodule\n"}
{"user_question": "Write a synthesizable Verilog module implementing a Mealy sequence detector that detects the sequence 1101 on a serial input stream. The output should go high when the sequence is detected.", "eval_prompt": "module mealy_seq_1101 (\n    input clk,\n    input reset,\n    input in,\n    output  out\n);\n    reg [2:0] state;\n    parameter S0 = 0;\n    parameter S1 = 1;\n    parameter S2 = 2;\n    parameter S3 = 3;\n    parameter S4 = 4;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) state <= S0;\n        else begin\n            case (state)\n                        S0: begin\n                if (in == 1) state <= S1;\n                else state <= S1;\n            end\n                        S1: begin\n                if (in == 1) state <= S2;\n                else state <= S1;\n            end\n                        S2: begin\n                if (in == 0) state <= S3;\n                else state <= S1;\n            end\n                        S3: begin\n                if (in == 1) state <= S4;\n                else state <= S1;\n            end\n            default: state <= S0;\n            endcase\n        end\n    end\n\n    assign out = 0; // Add Mealy output logic\nendmodule\n"}
{"user_question": "Write a synthesizable Verilog module implementing a Moore sequence detector that detects the sequence 1001 on a serial input stream. The output should go high when the sequence is detected.", "eval_prompt": "module moore_seq_1001 (\n    input clk,\n    input reset,\n    input in,\n    output reg out\n);\n    reg [2:0] state;\n    parameter S0 = 0;\n    parameter S1 = 1;\n    parameter S2 = 2;\n    parameter S3 = 3;\n    parameter S4 = 4;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) state <= S0;\n        else begin\n            case (state)\n                        S0: state <= (in == 1) ? S1 : S1;\n                        S1: state <= (in == 0) ? S2 : S1;\n                        S2: state <= (in == 0) ? S3 : S1;\n                        S3: state <= (in == 1) ? S4 : S1;\n            default: state <= S0;\n            endcase\n        end\n    end\n\n    assign out = (state == S4) ? 1'b1 : 1'b0;\nendmodule\n"}
{"user_question": "Write a synthesizable Verilog module implementing a Mealy sequence detector that detects the sequence 0110 on a serial input stream. The output should go high when the sequence is detected.", "eval_prompt": "module mealy_seq_0110 (\n    input clk,\n    input reset,\n    input in,\n    output  out\n);\n    reg [2:0] state;\n    parameter S0 = 0;\n    parameter S1 = 1;\n    parameter S2 = 2;\n    parameter S3 = 3;\n    parameter S4 = 4;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) state <= S0;\n        else begin\n            case (state)\n                        S0: begin\n                if (in == 0) state <= S1;\n                else state <= S0;\n            end\n                        S1: begin\n                if (in == 1) state <= S2;\n                else state <= S0;\n            end\n                        S2: begin\n                if (in == 1) state <= S3;\n                else state <= S0;\n            end\n                        S3: begin\n                if (in == 0) state <= S4;\n                else state <= S0;\n            end\n            default: state <= S0;\n            endcase\n        end\n    end\n\n    assign out = 0; // Add Mealy output logic\nendmodule\n"}
{"user_question": "Write a synthesizable Verilog module implementing a Moore sequence detector that detects the sequence 1110 on a serial input stream. The output should go high when the sequence is detected.", "eval_prompt": "module moore_seq_1110 (\n    input clk,\n    input reset,\n    input in,\n    output reg out\n);\n    reg [2:0] state;\n    parameter S0 = 0;\n    parameter S1 = 1;\n    parameter S2 = 2;\n    parameter S3 = 3;\n    parameter S4 = 4;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) state <= S0;\n        else begin\n            case (state)\n                        S0: state <= (in == 1) ? S1 : S1;\n                        S1: state <= (in == 1) ? S2 : S1;\n                        S2: state <= (in == 1) ? S3 : S1;\n                        S3: state <= (in == 0) ? S4 : S1;\n            default: state <= S0;\n            endcase\n        end\n    end\n\n    assign out = (state == S4) ? 1'b1 : 1'b0;\nendmodule\n"}
{"user_question": "Write a synthesizable Verilog module implementing a Mealy sequence detector that detects the sequence 0001 on a serial input stream. The output should go high when the sequence is detected.", "eval_prompt": "module mealy_seq_0001 (\n    input clk,\n    input reset,\n    input in,\n    output  out\n);\n    reg [2:0] state;\n    parameter S0 = 0;\n    parameter S1 = 1;\n    parameter S2 = 2;\n    parameter S3 = 3;\n    parameter S4 = 4;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) state <= S0;\n        else begin\n            case (state)\n                        S0: begin\n                if (in == 0) state <= S1;\n                else state <= S0;\n            end\n                        S1: begin\n                if (in == 0) state <= S2;\n                else state <= S0;\n            end\n                        S2: begin\n                if (in == 0) state <= S3;\n                else state <= S0;\n            end\n                        S3: begin\n                if (in == 1) state <= S4;\n                else state <= S0;\n            end\n            default: state <= S0;\n            endcase\n        end\n    end\n\n    assign out = 0; // Add Mealy output logic\nendmodule\n"}
{"user_question": "Write a synthesizable Verilog module implementing a Moore sequence detector that detects the sequence 1011 on a serial input stream. The output should go high when the sequence is detected.", "eval_prompt": "module moore_seq_1011 (\n    input clk,\n    input reset,\n    input in,\n    output reg out\n);\n    reg [2:0] state;\n    parameter S0 = 0;\n    parameter S1 = 1;\n    parameter S2 = 2;\n    parameter S3 = 3;\n    parameter S4 = 4;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) state <= S0;\n        else begin\n            case (state)\n                        S0: state <= (in == 1) ? S1 : S1;\n                        S1: state <= (in == 0) ? S2 : S1;\n                        S2: state <= (in == 1) ? S3 : S1;\n                        S3: state <= (in == 1) ? S4 : S1;\n            default: state <= S0;\n            endcase\n        end\n    end\n\n    assign out = (state == S4) ? 1'b1 : 1'b0;\nendmodule\n"}
{"user_question": "Write a synthesizable Verilog module implementing a Mealy sequence detector that detects the sequence 0101 on a serial input stream. The output should go high when the sequence is detected.", "eval_prompt": "module mealy_seq_0101 (\n    input clk,\n    input reset,\n    input in,\n    output  out\n);\n    reg [2:0] state;\n    parameter S0 = 0;\n    parameter S1 = 1;\n    parameter S2 = 2;\n    parameter S3 = 3;\n    parameter S4 = 4;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) state <= S0;\n        else begin\n            case (state)\n                        S0: begin\n                if (in == 0) state <= S1;\n                else state <= S0;\n            end\n                        S1: begin\n                if (in == 1) state <= S2;\n                else state <= S0;\n            end\n                        S2: begin\n                if (in == 0) state <= S3;\n                else state <= S0;\n            end\n                        S3: begin\n                if (in == 1) state <= S4;\n                else state <= S0;\n            end\n            default: state <= S0;\n            endcase\n        end\n    end\n\n    assign out = 0; // Add Mealy output logic\nendmodule\n"}
{"user_question": "Write a synthesizable Verilog module implementing a Moore sequence detector that detects the sequence 0011 on a serial input stream. The output should go high when the sequence is detected.", "eval_prompt": "module moore_seq_0011 (\n    input clk,\n    input reset,\n    input in,\n    output reg out\n);\n    reg [2:0] state;\n    parameter S0 = 0;\n    parameter S1 = 1;\n    parameter S2 = 2;\n    parameter S3 = 3;\n    parameter S4 = 4;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) state <= S0;\n        else begin\n            case (state)\n                        S0: state <= (in == 0) ? S1 : S0;\n                        S1: state <= (in == 0) ? S2 : S0;\n                        S2: state <= (in == 1) ? S3 : S0;\n                        S3: state <= (in == 1) ? S4 : S0;\n            default: state <= S0;\n            endcase\n        end\n    end\n\n    assign out = (state == S4) ? 1'b1 : 1'b0;\nendmodule\n"}
{"user_question": "Write a synthesizable Verilog module implementing a Mealy sequence detector that detects the sequence 0111 on a serial input stream. The output should go high when the sequence is detected.", "eval_prompt": "module mealy_seq_0111 (\n    input clk,\n    input reset,\n    input in,\n    output  out\n);\n    reg [2:0] state;\n    parameter S0 = 0;\n    parameter S1 = 1;\n    parameter S2 = 2;\n    parameter S3 = 3;\n    parameter S4 = 4;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) state <= S0;\n        else begin\n            case (state)\n                        S0: begin\n                if (in == 0) state <= S1;\n                else state <= S0;\n            end\n                        S1: begin\n                if (in == 1) state <= S2;\n                else state <= S0;\n            end\n                        S2: begin\n                if (in == 1) state <= S3;\n                else state <= S0;\n            end\n                        S3: begin\n                if (in == 1) state <= S4;\n                else state <= S0;\n            end\n            default: state <= S0;\n            endcase\n        end\n    end\n\n    assign out = 0; // Add Mealy output logic\nendmodule\n"}
{"user_question": "Write a synthesizable Verilog module implementing a Moore sequence detector that detects the sequence 1111 on a serial input stream. The output should go high when the sequence is detected.", "eval_prompt": "module moore_seq_1111 (\n    input clk,\n    input reset,\n    input in,\n    output reg out\n);\n    reg [2:0] state;\n    parameter S0 = 0;\n    parameter S1 = 1;\n    parameter S2 = 2;\n    parameter S3 = 3;\n    parameter S4 = 4;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) state <= S0;\n        else begin\n            case (state)\n                        S0: state <= (in == 1) ? S1 : S1;\n                        S1: state <= (in == 1) ? S2 : S1;\n                        S2: state <= (in == 1) ? S3 : S1;\n                        S3: state <= (in == 1) ? S4 : S1;\n            default: state <= S0;\n            endcase\n        end\n    end\n\n    assign out = (state == S4) ? 1'b1 : 1'b0;\nendmodule\n"}
{"user_question": "Write a synthesizable Verilog module implementing a Mealy sequence detector that detects the sequence 0000 on a serial input stream. The output should go high when the sequence is detected.", "eval_prompt": "module mealy_seq_0000 (\n    input clk,\n    input reset,\n    input in,\n    output  out\n);\n    reg [2:0] state;\n    parameter S0 = 0;\n    parameter S1 = 1;\n    parameter S2 = 2;\n    parameter S3 = 3;\n    parameter S4 = 4;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) state <= S0;\n        else begin\n            case (state)\n                        S0: begin\n                if (in == 0) state <= S1;\n                else state <= S0;\n            end\n                        S1: begin\n                if (in == 0) state <= S2;\n                else state <= S0;\n            end\n                        S2: begin\n                if (in == 0) state <= S3;\n                else state <= S0;\n            end\n                        S3: begin\n                if (in == 0) state <= S4;\n                else state <= S0;\n            end\n            default: state <= S0;\n            endcase\n        end\n    end\n\n    assign out = 0; // Add Mealy output logic\nendmodule\n"}
{"user_question": "Write a synthesizable Verilog module implementing a Moore sequence detector that detects the sequence 1100 on a serial input stream. The output should go high when the sequence is detected.", "eval_prompt": "module moore_seq_1100 (\n    input clk,\n    input reset,\n    input in,\n    output reg out\n);\n    reg [2:0] state;\n    parameter S0 = 0;\n    parameter S1 = 1;\n    parameter S2 = 2;\n    parameter S3 = 3;\n    parameter S4 = 4;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) state <= S0;\n        else begin\n            case (state)\n                        S0: state <= (in == 1) ? S1 : S1;\n                        S1: state <= (in == 1) ? S2 : S1;\n                        S2: state <= (in == 0) ? S3 : S1;\n                        S3: state <= (in == 0) ? S4 : S1;\n            default: state <= S0;\n            endcase\n        end\n    end\n\n    assign out = (state == S4) ? 1'b1 : 1'b0;\nendmodule\n"}
{"user_question": "Write a synthesizable Verilog module implementing a Mealy sequence detector that detects the sequence 0010 on a serial input stream. The output should go high when the sequence is detected.", "eval_prompt": "module mealy_seq_0010 (\n    input clk,\n    input reset,\n    input in,\n    output  out\n);\n    reg [2:0] state;\n    parameter S0 = 0;\n    parameter S1 = 1;\n    parameter S2 = 2;\n    parameter S3 = 3;\n    parameter S4 = 4;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) state <= S0;\n        else begin\n            case (state)\n                        S0: begin\n                if (in == 0) state <= S1;\n                else state <= S0;\n            end\n                        S1: begin\n                if (in == 0) state <= S2;\n                else state <= S0;\n            end\n                        S2: begin\n                if (in == 1) state <= S3;\n                else state <= S0;\n            end\n                        S3: begin\n                if (in == 0) state <= S4;\n                else state <= S0;\n            end\n            default: state <= S0;\n            endcase\n        end\n    end\n\n    assign out = 0; // Add Mealy output logic\nendmodule\n"}
{"user_question": "Write a synthesizable Verilog module implementing a Moore sequence detector that detects the sequence 1000 on a serial input stream. The output should go high when the sequence is detected.", "eval_prompt": "module moore_seq_1000 (\n    input clk,\n    input reset,\n    input in,\n    output reg out\n);\n    reg [2:0] state;\n    parameter S0 = 0;\n    parameter S1 = 1;\n    parameter S2 = 2;\n    parameter S3 = 3;\n    parameter S4 = 4;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) state <= S0;\n        else begin\n            case (state)\n                        S0: state <= (in == 1) ? S1 : S1;\n                        S1: state <= (in == 0) ? S2 : S1;\n                        S2: state <= (in == 0) ? S3 : S1;\n                        S3: state <= (in == 0) ? S4 : S1;\n            default: state <= S0;\n            endcase\n        end\n    end\n\n    assign out = (state == S4) ? 1'b1 : 1'b0;\nendmodule\n"}
{"user_question": "Write a synthesizable Verilog module implementing a Mealy sequence detector that detects the sequence 0100 on a serial input stream. The output should go high when the sequence is detected.", "eval_prompt": "module mealy_seq_0100 (\n    input clk,\n    input reset,\n    input in,\n    output  out\n);\n    reg [2:0] state;\n    parameter S0 = 0;\n    parameter S1 = 1;\n    parameter S2 = 2;\n    parameter S3 = 3;\n    parameter S4 = 4;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) state <= S0;\n        else begin\n            case (state)\n                        S0: begin\n                if (in == 0) state <= S1;\n                else state <= S0;\n            end\n                        S1: begin\n                if (in == 1) state <= S2;\n                else state <= S0;\n            end\n                        S2: begin\n                if (in == 0) state <= S3;\n                else state <= S0;\n            end\n                        S3: begin\n                if (in == 0) state <= S4;\n                else state <= S0;\n            end\n            default: state <= S0;\n            endcase\n        end\n    end\n\n    assign out = 0; // Add Mealy output logic\nendmodule\n"}
{"user_question": "Write a synthesizable Verilog module implementing a Moore sequence detector that detects the sequence 111 on a serial input stream. The output should go high when the sequence is detected.", "eval_prompt": "module moore_seq_111 (\n    input clk,\n    input reset,\n    input in,\n    output reg out\n);\n    reg [2:0] state;\n    parameter S0 = 0;\n    parameter S1 = 1;\n    parameter S2 = 2;\n    parameter S3 = 3;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) state <= S0;\n        else begin\n            case (state)\n                        S0: state <= (in == 1) ? S1 : S1;\n                        S1: state <= (in == 1) ? S2 : S1;\n                        S2: state <= (in == 1) ? S3 : S1;\n            default: state <= S0;\n            endcase\n        end\n    end\n\n    assign out = (state == S3) ? 1'b1 : 1'b0;\nendmodule\n"}
{"user_question": "Write a synthesizable Verilog module implementing a Mealy sequence detector that detects the sequence 011 on a serial input stream. The output should go high when the sequence is detected.", "eval_prompt": "module mealy_seq_011 (\n    input clk,\n    input reset,\n    input in,\n    output  out\n);\n    reg [2:0] state;\n    parameter S0 = 0;\n    parameter S1 = 1;\n    parameter S2 = 2;\n    parameter S3 = 3;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) state <= S0;\n        else begin\n            case (state)\n                        S0: begin\n                if (in == 0) state <= S1;\n                else state <= S0;\n            end\n                        S1: begin\n                if (in == 1) state <= S2;\n                else state <= S0;\n            end\n                        S2: begin\n                if (in == 1) state <= S3;\n                else state <= S0;\n            end\n            default: state <= S0;\n            endcase\n        end\n    end\n\n    assign out = 0; // Add Mealy output logic\nendmodule\n"}
{"user_question": "Write a synthesizable Verilog module implementing a Moore sequence detector that detects the sequence 101 on a serial input stream. The output should go high when the sequence is detected.", "eval_prompt": "module moore_seq_101 (\n    input clk,\n    input reset,\n    input in,\n    output reg out\n);\n    reg [2:0] state;\n    parameter S0 = 0;\n    parameter S1 = 1;\n    parameter S2 = 2;\n    parameter S3 = 3;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) state <= S0;\n        else begin\n            case (state)\n                        S0: state <= (in == 1) ? S1 : S1;\n                        S1: state <= (in == 0) ? S2 : S1;\n                        S2: state <= (in == 1) ? S3 : S1;\n            default: state <= S0;\n            endcase\n        end\n    end\n\n    assign out = (state == S3) ? 1'b1 : 1'b0;\nendmodule\n"}
{"user_question": "Write a synthesizable Verilog module implementing a Mealy sequence detector that detects the sequence 001 on a serial input stream. The output should go high when the sequence is detected.", "eval_prompt": "module mealy_seq_001 (\n    input clk,\n    input reset,\n    input in,\n    output  out\n);\n    reg [2:0] state;\n    parameter S0 = 0;\n    parameter S1 = 1;\n    parameter S2 = 2;\n    parameter S3 = 3;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) state <= S0;\n        else begin\n            case (state)\n                        S0: begin\n                if (in == 0) state <= S1;\n                else state <= S0;\n            end\n                        S1: begin\n                if (in == 0) state <= S2;\n                else state <= S0;\n            end\n                        S2: begin\n                if (in == 1) state <= S3;\n                else state <= S0;\n            end\n            default: state <= S0;\n            endcase\n        end\n    end\n\n    assign out = 0; // Add Mealy output logic\nendmodule\n"}
{"user_question": "Write a synthesizable Verilog module implementing a Moore sequence detector that detects the sequence 110 on a serial input stream. The output should go high when the sequence is detected.", "eval_prompt": "module moore_seq_110 (\n    input clk,\n    input reset,\n    input in,\n    output reg out\n);\n    reg [2:0] state;\n    parameter S0 = 0;\n    parameter S1 = 1;\n    parameter S2 = 2;\n    parameter S3 = 3;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) state <= S0;\n        else begin\n            case (state)\n                        S0: state <= (in == 1) ? S1 : S1;\n                        S1: state <= (in == 1) ? S2 : S1;\n                        S2: state <= (in == 0) ? S3 : S1;\n            default: state <= S0;\n            endcase\n        end\n    end\n\n    assign out = (state == S3) ? 1'b1 : 1'b0;\nendmodule\n"}
{"user_question": "Write a Verilog module for an 4-bit synchronous up counter with reset and enable signals.", "eval_prompt": "module counter_4bit (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 0;\n        else if (enable)\n            count <= count + 1;\n    end\n\nendmodule"}
{"user_question": "Write a Verilog module for an 5-bit synchronous up counter with reset and enable signals.", "eval_prompt": "module counter_5bit (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    output reg [4:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 0;\n        else if (enable)\n            count <= count + 1;\n    end\n\nendmodule"}
{"user_question": "Write a Verilog module for an 6-bit synchronous up counter with reset and enable signals.", "eval_prompt": "module counter_6bit (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    output reg [5:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 0;\n        else if (enable)\n            count <= count + 1;\n    end\n\nendmodule"}
{"user_question": "Write a Verilog module for an 7-bit synchronous up counter with reset and enable signals.", "eval_prompt": "module counter_7bit (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    output reg [6:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 0;\n        else if (enable)\n            count <= count + 1;\n    end\n\nendmodule"}
{"user_question": "Write a Verilog module for an 8-bit synchronous up counter with reset and enable signals.", "eval_prompt": "module counter_8bit (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    output reg [7:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 0;\n        else if (enable)\n            count <= count + 1;\n    end\n\nendmodule"}
{"user_question": "Write a Verilog module for an 9-bit synchronous up counter with reset and enable signals.", "eval_prompt": "module counter_9bit (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    output reg [8:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 0;\n        else if (enable)\n            count <= count + 1;\n    end\n\nendmodule"}
{"user_question": "Write a Verilog module for an 10-bit synchronous up counter with reset and enable signals.", "eval_prompt": "module counter_10bit (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    output reg [9:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 0;\n        else if (enable)\n            count <= count + 1;\n    end\n\nendmodule"}
{"user_question": "Write a Verilog module for an 11-bit synchronous up counter with reset and enable signals.", "eval_prompt": "module counter_11bit (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    output reg [10:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 0;\n        else if (enable)\n            count <= count + 1;\n    end\n\nendmodule"}
{"user_question": "Write a Verilog module for an 12-bit synchronous up counter with reset and enable signals.", "eval_prompt": "module counter_12bit (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    output reg [11:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 0;\n        else if (enable)\n            count <= count + 1;\n    end\n\nendmodule"}
{"user_question": "Write a Verilog module for an 13-bit synchronous up counter with reset and enable signals.", "eval_prompt": "module counter_13bit (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    output reg [12:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 0;\n        else if (enable)\n            count <= count + 1;\n    end\n\nendmodule"}
{"user_question": "Write a Verilog module for an 14-bit synchronous up counter with reset and enable signals.", "eval_prompt": "module counter_14bit (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    output reg [13:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 0;\n        else if (enable)\n            count <= count + 1;\n    end\n\nendmodule"}
{"user_question": "Write a Verilog module for an 15-bit synchronous up counter with reset and enable signals.", "eval_prompt": "module counter_15bit (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    output reg [14:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 0;\n        else if (enable)\n            count <= count + 1;\n    end\n\nendmodule"}
{"user_question": "Write a Verilog module for an 16-bit synchronous up counter with reset and enable signals.", "eval_prompt": "module counter_16bit (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    output reg [15:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 0;\n        else if (enable)\n            count <= count + 1;\n    end\n\nendmodule"}
{"user_question": "Write a Verilog module for an 17-bit synchronous up counter with reset and enable signals.", "eval_prompt": "module counter_17bit (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    output reg [16:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 0;\n        else if (enable)\n            count <= count + 1;\n    end\n\nendmodule"}
{"user_question": "Write a Verilog module for an 18-bit synchronous up counter with reset and enable signals.", "eval_prompt": "module counter_18bit (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    output reg [17:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 0;\n        else if (enable)\n            count <= count + 1;\n    end\n\nendmodule"}
{"user_question": "Write a Verilog module for an 19-bit synchronous up counter with reset and enable signals.", "eval_prompt": "module counter_19bit (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    output reg [18:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 0;\n        else if (enable)\n            count <= count + 1;\n    end\n\nendmodule"}
{"user_question": "Write a Verilog module for an 20-bit synchronous up counter with reset and enable signals.", "eval_prompt": "module counter_20bit (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    output reg [19:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 0;\n        else if (enable)\n            count <= count + 1;\n    end\n\nendmodule"}
{"user_question": "Write a Verilog module for an 21-bit synchronous up counter with reset and enable signals.", "eval_prompt": "module counter_21bit (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    output reg [20:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 0;\n        else if (enable)\n            count <= count + 1;\n    end\n\nendmodule"}
{"user_question": "Write a Verilog module for an 22-bit synchronous up counter with reset and enable signals.", "eval_prompt": "module counter_22bit (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    output reg [21:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 0;\n        else if (enable)\n            count <= count + 1;\n    end\n\nendmodule"}
{"user_question": "Write a Verilog module for an 23-bit synchronous up counter with reset and enable signals.", "eval_prompt": "module counter_23bit (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    output reg [22:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 0;\n        else if (enable)\n            count <= count + 1;\n    end\n\nendmodule"}
{"user_question": "Write a Verilog ALU with 4-bit inputs and opcode supporting: ADD, SUB, AND, OR.", "eval_prompt": "module alu_varied_1 (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire [2:0] opcode,\n    output reg [3:0] result\n);\n\n    always @(*) begin\n        case (opcode)\n            3'b000: result = a + b\n            3'b001: result = a - b\n            default: result = 0;\n        endcase\n    end\n\nendmodule"}
{"user_question": "Write a Verilog ALU with 4-bit inputs and opcode supporting: XOR, NOT.", "eval_prompt": "module alu_varied_2 (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire [2:0] opcode,\n    output reg [3:0] result\n);\n\n    always @(*) begin\n        case (opcode)\n            3'b000: result = a ^ b\n            3'b001: result = ~a\n            default: result = 0;\n        endcase\n    end\n\nendmodule"}
{"user_question": "Write a Verilog ALU with 4-bit inputs and opcode supporting: Left/Right shift.", "eval_prompt": "module alu_varied_3 (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire [2:0] opcode,\n    output reg [3:0] result\n);\n\n    always @(*) begin\n        case (opcode)\n            3'b000: result = a << 1\n            3'b001: result = a >> 1\n            default: result = 0;\n        endcase\n    end\n\nendmodule"}
{"user_question": "Write a Verilog ALU with 4-bit inputs and opcode supporting: Multiply and Compare.", "eval_prompt": "module alu_varied_4 (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire [2:0] opcode,\n    output reg [3:0] result\n);\n\n    always @(*) begin\n        case (opcode)\n            3'b000: result = a * b\n            3'b001: result = (a > b) ? 4'b0001 : 4'b0000\n            default: result = 0;\n        endcase\n    end\n\nendmodule"}
{"user_question": "Write a Verilog ALU with 4-bit inputs and opcode supporting: Set less than.", "eval_prompt": "module alu_varied_5 (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire [2:0] opcode,\n    output reg [3:0] result\n);\n\n    always @(*) begin\n        case (opcode)\n            3'b000: result = (a < b) ? 1 : 0\n            3'b001: \n            default: result = 0;\n        endcase\n    end\n\nendmodule"}
{"user_question": "Write a Verilog ALU with 4-bit inputs and opcode supporting: ADD, SUB, AND, OR.", "eval_prompt": "module alu_varied_6 (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire [2:0] opcode,\n    output reg [3:0] result\n);\n\n    always @(*) begin\n        case (opcode)\n            3'b000: result = a + b\n            3'b001: result = a - b\n            default: result = 0;\n        endcase\n    end\n\nendmodule"}
{"user_question": "Write a Verilog ALU with 4-bit inputs and opcode supporting: XOR, NOT.", "eval_prompt": "module alu_varied_7 (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire [2:0] opcode,\n    output reg [3:0] result\n);\n\n    always @(*) begin\n        case (opcode)\n            3'b000: result = a ^ b\n            3'b001: result = ~a\n            default: result = 0;\n        endcase\n    end\n\nendmodule"}
{"user_question": "Write a Verilog ALU with 4-bit inputs and opcode supporting: Left/Right shift.", "eval_prompt": "module alu_varied_8 (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire [2:0] opcode,\n    output reg [3:0] result\n);\n\n    always @(*) begin\n        case (opcode)\n            3'b000: result = a << 1\n            3'b001: result = a >> 1\n            default: result = 0;\n        endcase\n    end\n\nendmodule"}
{"user_question": "Write a Verilog ALU with 4-bit inputs and opcode supporting: Multiply and Compare.", "eval_prompt": "module alu_varied_9 (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire [2:0] opcode,\n    output reg [3:0] result\n);\n\n    always @(*) begin\n        case (opcode)\n            3'b000: result = a * b\n            3'b001: result = (a > b) ? 4'b0001 : 4'b0000\n            default: result = 0;\n        endcase\n    end\n\nendmodule"}
{"user_question": "Write a Verilog ALU with 4-bit inputs and opcode supporting: Set less than.", "eval_prompt": "module alu_varied_10 (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire [2:0] opcode,\n    output reg [3:0] result\n);\n\n    always @(*) begin\n        case (opcode)\n            3'b000: result = (a < b) ? 1 : 0\n            3'b001: \n            default: result = 0;\n        endcase\n    end\n\nendmodule"}
{"user_question": "Write a Verilog ALU with 4-bit inputs and opcode supporting: ADD, SUB, AND, OR.", "eval_prompt": "module alu_varied_11 (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire [2:0] opcode,\n    output reg [3:0] result\n);\n\n    always @(*) begin\n        case (opcode)\n            3'b000: result = a + b\n            3'b001: result = a - b\n            default: result = 0;\n        endcase\n    end\n\nendmodule"}
{"user_question": "Write a Verilog ALU with 4-bit inputs and opcode supporting: XOR, NOT.", "eval_prompt": "module alu_varied_12 (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire [2:0] opcode,\n    output reg [3:0] result\n);\n\n    always @(*) begin\n        case (opcode)\n            3'b000: result = a ^ b\n            3'b001: result = ~a\n            default: result = 0;\n        endcase\n    end\n\nendmodule"}
{"user_question": "Write a Verilog ALU with 4-bit inputs and opcode supporting: Left/Right shift.", "eval_prompt": "module alu_varied_13 (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire [2:0] opcode,\n    output reg [3:0] result\n);\n\n    always @(*) begin\n        case (opcode)\n            3'b000: result = a << 1\n            3'b001: result = a >> 1\n            default: result = 0;\n        endcase\n    end\n\nendmodule"}
{"user_question": "Write a Verilog ALU with 4-bit inputs and opcode supporting: Multiply and Compare.", "eval_prompt": "module alu_varied_14 (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire [2:0] opcode,\n    output reg [3:0] result\n);\n\n    always @(*) begin\n        case (opcode)\n            3'b000: result = a * b\n            3'b001: result = (a > b) ? 4'b0001 : 4'b0000\n            default: result = 0;\n        endcase\n    end\n\nendmodule"}
{"user_question": "Write a Verilog ALU with 4-bit inputs and opcode supporting: Set less than.", "eval_prompt": "module alu_varied_15 (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire [2:0] opcode,\n    output reg [3:0] result\n);\n\n    always @(*) begin\n        case (opcode)\n            3'b000: result = (a < b) ? 1 : 0\n            3'b001: \n            default: result = 0;\n        endcase\n    end\n\nendmodule"}
{"user_question": "Write a Verilog ALU with 4-bit inputs and opcode supporting: ADD, SUB, AND, OR.", "eval_prompt": "module alu_varied_16 (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire [2:0] opcode,\n    output reg [3:0] result\n);\n\n    always @(*) begin\n        case (opcode)\n            3'b000: result = a + b\n            3'b001: result = a - b\n            default: result = 0;\n        endcase\n    end\n\nendmodule"}
{"user_question": "Write a Verilog ALU with 4-bit inputs and opcode supporting: XOR, NOT.", "eval_prompt": "module alu_varied_17 (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire [2:0] opcode,\n    output reg [3:0] result\n);\n\n    always @(*) begin\n        case (opcode)\n            3'b000: result = a ^ b\n            3'b001: result = ~a\n            default: result = 0;\n        endcase\n    end\n\nendmodule"}
{"user_question": "Write a Verilog ALU with 4-bit inputs and opcode supporting: Left/Right shift.", "eval_prompt": "module alu_varied_18 (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire [2:0] opcode,\n    output reg [3:0] result\n);\n\n    always @(*) begin\n        case (opcode)\n            3'b000: result = a << 1\n            3'b001: result = a >> 1\n            default: result = 0;\n        endcase\n    end\n\nendmodule"}
{"user_question": "Write a Verilog ALU with 4-bit inputs and opcode supporting: Multiply and Compare.", "eval_prompt": "module alu_varied_19 (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire [2:0] opcode,\n    output reg [3:0] result\n);\n\n    always @(*) begin\n        case (opcode)\n            3'b000: result = a * b\n            3'b001: result = (a > b) ? 4'b0001 : 4'b0000\n            default: result = 0;\n        endcase\n    end\n\nendmodule"}
{"user_question": "Write a Verilog ALU with 4-bit inputs and opcode supporting: Set less than.", "eval_prompt": "module alu_varied_20 (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire [2:0] opcode,\n    output reg [3:0] result\n);\n\n    always @(*) begin\n        case (opcode)\n            3'b000: result = (a < b) ? 1 : 0\n            3'b001: \n            default: result = 0;\n        endcase\n    end\n\nendmodule"}
{"user_question": "Write a Verilog module for a D flip-flop with asynchronous reset.", "eval_prompt": "module d_flipflop_async (\n    input wire clk,\n    input wire reset,\n    input wire d,\n    output reg q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) q <= 0;\n        else q <= d;\n    end\nendmodule"}
{"user_question": "Write a Verilog module for a D flip-flop with synchronous reset.", "eval_prompt": "module d_flipflop_sync (\n    input wire clk,\n    input wire reset,\n    input wire d,\n    output reg q\n);\n    always @(posedge clk) begin\n        if (reset) q <= 0;\n        else q <= d;\n    end\nendmodule"}
{"user_question": "Write a Verilog module for a T flip-flop with toggle on T=1.", "eval_prompt": "module t_flipflop (\n    input wire clk,\n    input wire reset,\n    input wire t,\n    output reg q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) q <= 0;\n        else if (t) q <= ~q;\n    end\nendmodule"}
{"user_question": "Write a Verilog module for a JK flip-flop.", "eval_prompt": "module jk_flipflop (\n    input wire clk,\n    input wire reset,\n    input wire j,\n    input wire k,\n    output reg q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) q <= 0;\n        else if (~j & k) q <= 0;\n        else if (j & ~k) q <= 1;\n        else if (j & k) q <= ~q;\n    end\nendmodule"}
{"user_question": "Write a Verilog module for a SR flip-flop.", "eval_prompt": "module sr_flipflop (\n    input wire clk,\n    input wire s,\n    input wire r,\n    output reg q\n);\n    always @(posedge clk) begin\n        if (s & ~r) q <= 1;\n        else if (~s & r) q <= 0;\n    end\nendmodule"}
{"user_question": "Write a Verilog module for a Master-slave D flip-flop.", "eval_prompt": "module master_slave_dff (\n    input wire clk,\n    input wire d,\n    output reg q\n);\n    reg q_m;\n    always @(posedge clk)\n        q_m <= d;\n    always @(negedge clk)\n        q <= q_m;\nendmodule"}
{"user_question": "Write a Verilog module for a D flip-flop with asynchronous reset.", "eval_prompt": "module d_flipflop_async (\n    input wire clk,\n    input wire reset,\n    input wire d,\n    output reg q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) q <= 0;\n        else q <= d;\n    end\nendmodule"}
{"user_question": "Write a Verilog module for a D flip-flop with synchronous reset.", "eval_prompt": "module d_flipflop_sync (\n    input wire clk,\n    input wire reset,\n    input wire d,\n    output reg q\n);\n    always @(posedge clk) begin\n        if (reset) q <= 0;\n        else q <= d;\n    end\nendmodule"}
{"user_question": "Write a Verilog module for a T flip-flop with toggle on T=1.", "eval_prompt": "module t_flipflop (\n    input wire clk,\n    input wire reset,\n    input wire t,\n    output reg q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) q <= 0;\n        else if (t) q <= ~q;\n    end\nendmodule"}
{"user_question": "Write a Verilog module for a JK flip-flop.", "eval_prompt": "module jk_flipflop (\n    input wire clk,\n    input wire reset,\n    input wire j,\n    input wire k,\n    output reg q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) q <= 0;\n        else if (~j & k) q <= 0;\n        else if (j & ~k) q <= 1;\n        else if (j & k) q <= ~q;\n    end\nendmodule"}
{"user_question": "Write a Verilog module for a SR flip-flop.", "eval_prompt": "module sr_flipflop (\n    input wire clk,\n    input wire s,\n    input wire r,\n    output reg q\n);\n    always @(posedge clk) begin\n        if (s & ~r) q <= 1;\n        else if (~s & r) q <= 0;\n    end\nendmodule"}
{"user_question": "Write a Verilog module for a Master-slave D flip-flop.", "eval_prompt": "module master_slave_dff (\n    input wire clk,\n    input wire d,\n    output reg q\n);\n    reg q_m;\n    always @(posedge clk)\n        q_m <= d;\n    always @(negedge clk)\n        q <= q_m;\nendmodule"}
{"user_question": "Write a Verilog module for a D flip-flop with asynchronous reset.", "eval_prompt": "module d_flipflop_async (\n    input wire clk,\n    input wire reset,\n    input wire d,\n    output reg q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) q <= 0;\n        else q <= d;\n    end\nendmodule"}
{"user_question": "Write a Verilog module for a D flip-flop with synchronous reset.", "eval_prompt": "module d_flipflop_sync (\n    input wire clk,\n    input wire reset,\n    input wire d,\n    output reg q\n);\n    always @(posedge clk) begin\n        if (reset) q <= 0;\n        else q <= d;\n    end\nendmodule"}
{"user_question": "Write a Verilog module for a T flip-flop with toggle on T=1.", "eval_prompt": "module t_flipflop (\n    input wire clk,\n    input wire reset,\n    input wire t,\n    output reg q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) q <= 0;\n        else if (t) q <= ~q;\n    end\nendmodule"}
{"user_question": "Write a Verilog module for a JK flip-flop.", "eval_prompt": "module jk_flipflop (\n    input wire clk,\n    input wire reset,\n    input wire j,\n    input wire k,\n    output reg q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) q <= 0;\n        else if (~j & k) q <= 0;\n        else if (j & ~k) q <= 1;\n        else if (j & k) q <= ~q;\n    end\nendmodule"}
{"user_question": "Write a Verilog module for a SR flip-flop.", "eval_prompt": "module sr_flipflop (\n    input wire clk,\n    input wire s,\n    input wire r,\n    output reg q\n);\n    always @(posedge clk) begin\n        if (s & ~r) q <= 1;\n        else if (~s & r) q <= 0;\n    end\nendmodule"}
{"user_question": "Write a Verilog module for a Master-slave D flip-flop.", "eval_prompt": "module master_slave_dff (\n    input wire clk,\n    input wire d,\n    output reg q\n);\n    reg q_m;\n    always @(posedge clk)\n        q_m <= d;\n    always @(negedge clk)\n        q <= q_m;\nendmodule"}
{"user_question": "Write a Verilog module for a D flip-flop with asynchronous reset.", "eval_prompt": "module d_flipflop_async (\n    input wire clk,\n    input wire reset,\n    input wire d,\n    output reg q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) q <= 0;\n        else q <= d;\n    end\nendmodule"}
{"user_question": "Write a Verilog module for a D flip-flop with synchronous reset.", "eval_prompt": "module d_flipflop_sync (\n    input wire clk,\n    input wire reset,\n    input wire d,\n    output reg q\n);\n    always @(posedge clk) begin\n        if (reset) q <= 0;\n        else q <= d;\n    end\nendmodule"}
{"user_question": "Design a Verilog module for a 4-bit full adder using bitwise logic with carry propagation.", "eval_prompt": "module full_adder_4bit (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire cin,\n    output wire [3:0] sum,\n    output wire cout\n);\n    wire [4:0] carry;\n    assign carry[0] = cin;\n\n    genvar i;\n    generate\n        for (i = 0; i < 4; i = i + 1) begin : adder\n            assign sum[i] = a[i] ^ b[i] ^ carry[i];\n            assign carry[i+1] = (a[i] & b[i]) | (a[i] & carry[i]) | (b[i] & carry[i]);\n        end\n    endgenerate\n\n    assign cout = carry[4];\nendmodule"}
{"user_question": "Design a Verilog module for a 5-bit full adder using bitwise logic with carry propagation.", "eval_prompt": "module full_adder_5bit (\n    input wire [4:0] a,\n    input wire [4:0] b,\n    input wire cin,\n    output wire [4:0] sum,\n    output wire cout\n);\n    wire [5:0] carry;\n    assign carry[0] = cin;\n\n    genvar i;\n    generate\n        for (i = 0; i < 5; i = i + 1) begin : adder\n            assign sum[i] = a[i] ^ b[i] ^ carry[i];\n            assign carry[i+1] = (a[i] & b[i]) | (a[i] & carry[i]) | (b[i] & carry[i]);\n        end\n    endgenerate\n\n    assign cout = carry[5];\nendmodule"}
{"user_question": "Design a Verilog module for a 6-bit full adder using bitwise logic with carry propagation.", "eval_prompt": "module full_adder_6bit (\n    input wire [5:0] a,\n    input wire [5:0] b,\n    input wire cin,\n    output wire [5:0] sum,\n    output wire cout\n);\n    wire [6:0] carry;\n    assign carry[0] = cin;\n\n    genvar i;\n    generate\n        for (i = 0; i < 6; i = i + 1) begin : adder\n            assign sum[i] = a[i] ^ b[i] ^ carry[i];\n            assign carry[i+1] = (a[i] & b[i]) | (a[i] & carry[i]) | (b[i] & carry[i]);\n        end\n    endgenerate\n\n    assign cout = carry[6];\nendmodule"}
{"user_question": "Design a Verilog module for a 7-bit full adder using bitwise logic with carry propagation.", "eval_prompt": "module full_adder_7bit (\n    input wire [6:0] a,\n    input wire [6:0] b,\n    input wire cin,\n    output wire [6:0] sum,\n    output wire cout\n);\n    wire [7:0] carry;\n    assign carry[0] = cin;\n\n    genvar i;\n    generate\n        for (i = 0; i < 7; i = i + 1) begin : adder\n            assign sum[i] = a[i] ^ b[i] ^ carry[i];\n            assign carry[i+1] = (a[i] & b[i]) | (a[i] & carry[i]) | (b[i] & carry[i]);\n        end\n    endgenerate\n\n    assign cout = carry[7];\nendmodule"}
{"user_question": "Design a Verilog module for a 8-bit full adder using bitwise logic with carry propagation.", "eval_prompt": "module full_adder_8bit (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire cin,\n    output wire [7:0] sum,\n    output wire cout\n);\n    wire [8:0] carry;\n    assign carry[0] = cin;\n\n    genvar i;\n    generate\n        for (i = 0; i < 8; i = i + 1) begin : adder\n            assign sum[i] = a[i] ^ b[i] ^ carry[i];\n            assign carry[i+1] = (a[i] & b[i]) | (a[i] & carry[i]) | (b[i] & carry[i]);\n        end\n    endgenerate\n\n    assign cout = carry[8];\nendmodule"}
{"user_question": "Design a Verilog module for a 9-bit full adder using bitwise logic with carry propagation.", "eval_prompt": "module full_adder_9bit (\n    input wire [8:0] a,\n    input wire [8:0] b,\n    input wire cin,\n    output wire [8:0] sum,\n    output wire cout\n);\n    wire [9:0] carry;\n    assign carry[0] = cin;\n\n    genvar i;\n    generate\n        for (i = 0; i < 9; i = i + 1) begin : adder\n            assign sum[i] = a[i] ^ b[i] ^ carry[i];\n            assign carry[i+1] = (a[i] & b[i]) | (a[i] & carry[i]) | (b[i] & carry[i]);\n        end\n    endgenerate\n\n    assign cout = carry[9];\nendmodule"}
{"user_question": "Design a Verilog module for a 10-bit full adder using bitwise logic with carry propagation.", "eval_prompt": "module full_adder_10bit (\n    input wire [9:0] a,\n    input wire [9:0] b,\n    input wire cin,\n    output wire [9:0] sum,\n    output wire cout\n);\n    wire [10:0] carry;\n    assign carry[0] = cin;\n\n    genvar i;\n    generate\n        for (i = 0; i < 10; i = i + 1) begin : adder\n            assign sum[i] = a[i] ^ b[i] ^ carry[i];\n            assign carry[i+1] = (a[i] & b[i]) | (a[i] & carry[i]) | (b[i] & carry[i]);\n        end\n    endgenerate\n\n    assign cout = carry[10];\nendmodule"}
{"user_question": "Design a Verilog module for a 11-bit full adder using bitwise logic with carry propagation.", "eval_prompt": "module full_adder_11bit (\n    input wire [10:0] a,\n    input wire [10:0] b,\n    input wire cin,\n    output wire [10:0] sum,\n    output wire cout\n);\n    wire [11:0] carry;\n    assign carry[0] = cin;\n\n    genvar i;\n    generate\n        for (i = 0; i < 11; i = i + 1) begin : adder\n            assign sum[i] = a[i] ^ b[i] ^ carry[i];\n            assign carry[i+1] = (a[i] & b[i]) | (a[i] & carry[i]) | (b[i] & carry[i]);\n        end\n    endgenerate\n\n    assign cout = carry[11];\nendmodule"}
{"user_question": "Design a Verilog module for a 12-bit full adder using bitwise logic with carry propagation.", "eval_prompt": "module full_adder_12bit (\n    input wire [11:0] a,\n    input wire [11:0] b,\n    input wire cin,\n    output wire [11:0] sum,\n    output wire cout\n);\n    wire [12:0] carry;\n    assign carry[0] = cin;\n\n    genvar i;\n    generate\n        for (i = 0; i < 12; i = i + 1) begin : adder\n            assign sum[i] = a[i] ^ b[i] ^ carry[i];\n            assign carry[i+1] = (a[i] & b[i]) | (a[i] & carry[i]) | (b[i] & carry[i]);\n        end\n    endgenerate\n\n    assign cout = carry[12];\nendmodule"}
{"user_question": "Design a Verilog module for a 13-bit full adder using bitwise logic with carry propagation.", "eval_prompt": "module full_adder_13bit (\n    input wire [12:0] a,\n    input wire [12:0] b,\n    input wire cin,\n    output wire [12:0] sum,\n    output wire cout\n);\n    wire [13:0] carry;\n    assign carry[0] = cin;\n\n    genvar i;\n    generate\n        for (i = 0; i < 13; i = i + 1) begin : adder\n            assign sum[i] = a[i] ^ b[i] ^ carry[i];\n            assign carry[i+1] = (a[i] & b[i]) | (a[i] & carry[i]) | (b[i] & carry[i]);\n        end\n    endgenerate\n\n    assign cout = carry[13];\nendmodule"}
{"user_question": "Write a Verilog module for a 13-bit ripple carry adder.", "eval_prompt": "module ripple_adder_13bit (\n    input wire [12:0] a,\n    input wire [12:0] b,\n    output wire [13:0] sum\n);\n\n    assign sum = a + b;\n\nendmodule"}
{"user_question": "Write a Verilog module for a 2-to-1 multiplexer using a case statement.", "eval_prompt": "module mux_2to1 (\n    input wire [1:0] inputs,\n    input wire [$clog2(2)-1:0] sel,\n    output reg out\n);\n\n    always @(*) begin\n        case (sel)\n            0: out = inputs[0];\n            1: out = inputs[1];\n            default: out = 0;\n        endcase\n    end\n\nendmodule"}
{"user_question": "Write a Verilog module for a 3-to-1 multiplexer using a case statement.", "eval_prompt": "module mux_3to1 (\n    input wire [2:0] inputs,\n    input wire [$clog2(3)-1:0] sel,\n    output reg out\n);\n\n    always @(*) begin\n        case (sel)\n            0: out = inputs[0];\n            1: out = inputs[1];\n            2: out = inputs[2];\n            default: out = 0;\n        endcase\n    end\n\nendmodule"}
{"user_question": "Write a Verilog module for a 4-to-1 multiplexer using a case statement.", "eval_prompt": "module mux_4to1 (\n    input wire [3:0] inputs,\n    input wire [$clog2(4)-1:0] sel,\n    output reg out\n);\n\n    always @(*) begin\n        case (sel)\n            0: out = inputs[0];\n            1: out = inputs[1];\n            2: out = inputs[2];\n            3: out = inputs[3];\n            default: out = 0;\n        endcase\n    end\n\nendmodule"}
{"user_question": "Write a Verilog module for a 5-to-1 multiplexer using a case statement.", "eval_prompt": "module mux_5to1 (\n    input wire [4:0] inputs,\n    input wire [$clog2(5)-1:0] sel,\n    output reg out\n);\n\n    always @(*) begin\n        case (sel)\n            0: out = inputs[0];\n            1: out = inputs[1];\n            2: out = inputs[2];\n            3: out = inputs[3];\n            4: out = inputs[4];\n            default: out = 0;\n        endcase\n    end\n\nendmodule"}
{"user_question": "Write a Verilog module for a 6-to-1 multiplexer using a case statement.", "eval_prompt": "module mux_6to1 (\n    input wire [5:0] inputs,\n    input wire [$clog2(6)-1:0] sel,\n    output reg out\n);\n\n    always @(*) begin\n        case (sel)\n            0: out = inputs[0];\n            1: out = inputs[1];\n            2: out = inputs[2];\n            3: out = inputs[3];\n            4: out = inputs[4];\n            5: out = inputs[5];\n            default: out = 0;\n        endcase\n    end\n\nendmodule"}
{"user_question": "Write a Verilog module for a 7-to-1 multiplexer using a case statement.", "eval_prompt": "module mux_7to1 (\n    input wire [6:0] inputs,\n    input wire [$clog2(7)-1:0] sel,\n    output reg out\n);\n\n    always @(*) begin\n        case (sel)\n            0: out = inputs[0];\n            1: out = inputs[1];\n            2: out = inputs[2];\n            3: out = inputs[3];\n            4: out = inputs[4];\n            5: out = inputs[5];\n            6: out = inputs[6];\n            default: out = 0;\n        endcase\n    end\n\nendmodule"}
{"user_question": "Write a Verilog module for a 8-to-1 multiplexer using a case statement.", "eval_prompt": "module mux_8to1 (\n    input wire [7:0] inputs,\n    input wire [$clog2(8)-1:0] sel,\n    output reg out\n);\n\n    always @(*) begin\n        case (sel)\n            0: out = inputs[0];\n            1: out = inputs[1];\n            2: out = inputs[2];\n            3: out = inputs[3];\n            4: out = inputs[4];\n            5: out = inputs[5];\n            6: out = inputs[6];\n            7: out = inputs[7];\n            default: out = 0;\n        endcase\n    end\n\nendmodule"}
{"user_question": "Write a Verilog module for a 9-to-1 multiplexer using a case statement.", "eval_prompt": "module mux_9to1 (\n    input wire [8:0] inputs,\n    input wire [$clog2(9)-1:0] sel,\n    output reg out\n);\n\n    always @(*) begin\n        case (sel)\n            0: out = inputs[0];\n            1: out = inputs[1];\n            2: out = inputs[2];\n            3: out = inputs[3];\n            4: out = inputs[4];\n            5: out = inputs[5];\n            6: out = inputs[6];\n            7: out = inputs[7];\n            8: out = inputs[8];\n            default: out = 0;\n        endcase\n    end\n\nendmodule"}
{"user_question": "Write a Verilog module for a 10-to-1 multiplexer using a case statement.", "eval_prompt": "module mux_10to1 (\n    input wire [9:0] inputs,\n    input wire [$clog2(10)-1:0] sel,\n    output reg out\n);\n\n    always @(*) begin\n        case (sel)\n            0: out = inputs[0];\n            1: out = inputs[1];\n            2: out = inputs[2];\n            3: out = inputs[3];\n            4: out = inputs[4];\n            5: out = inputs[5];\n            6: out = inputs[6];\n            7: out = inputs[7];\n            8: out = inputs[8];\n            9: out = inputs[9];\n            default: out = 0;\n        endcase\n    end\n\nendmodule"}
