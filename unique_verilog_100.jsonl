{"code": "module up_counter_4bit_0 (\n    input wire clk,\n    input wire reset,\n    output reg [3:0] count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 4'b0000;\n        else\n            count <= count + 1;\n    end\nendmodule\n"}
{"code": "module down_counter_8bit_0 (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 8'hFF;\n        else\n            count <= count - 1;\n    end\nendmodule\n"}
{"code": "module gray_counter_4bit_0 (\n    input wire clk,\n    input wire reset,\n    output reg [3:0] gray\n);\n    reg [3:0] binary;\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            binary <= 4'b0000;\n            gray <= 4'b0000;\n        end else begin\n            binary <= binary + 1;\n            gray <= binary ^ (binary >> 1);\n        end\n    end\nendmodule\n"}
{"code": "module ring_counter_8bit_0 (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            out <= 8'b00000001;\n        else\n            out <= {out[6:0], out[7]};\n    end\nendmodule\n"}
{"code": "module alu_4bit_0 (\n    input wire [3:0] a, b,\n    input wire [1:0] sel,\n    output reg [3:0] result\n);\n    always @(*) begin\n        case(sel)\n            2'b00: result = a + b;\n            2'b01: result = a - b;\n            2'b10: result = a & b;\n            2'b11: result = a | b;\n        endcase\n    end\nendmodule\n"}
{"code": "module alu_8bit_0 (\n    input wire [7:0] a, b,\n    input wire [2:0] sel,\n    output reg [7:0] result\n);\n    always @(*) begin\n        case(sel)\n            3'b000: result = a + b;\n            3'b001: result = a - b;\n            3'b010: result = a & b;\n            3'b011: result = a | b;\n            3'b100: result = a ^ b;\n            3'b101: result = ~a;\n            3'b110: result = b << 1;\n            3'b111: result = b >> 1;\n        endcase\n    end\nendmodule\n"}
{"code": "module fsm_4bit_seqdet_0 (\n    input wire clk,\n    input wire reset,\n    input wire in,\n    output reg detected\n);\n    typedef enum logic [1:0] {S0, S1, S2, S3} state_t;\n    state_t state, next;\n\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= S0;\n        else\n            state <= next;\n    end\n\n    always_comb begin\n        case (state)\n            S0: next = in ? S1 : S0;\n            S1: next = in ? S1 : S2;\n            S2: next = in ? S3 : S0;\n            S3: next = in ? S1 : S0;\n        endcase\n    end\n\n    always_comb begin\n        detected = (state == S3 && in == 1);\n    end\nendmodule\n"}
{"code": "module fsm_8bit_seqdet_0 (\n    input wire clk,\n    input wire reset,\n    input wire [7:0] in,\n    output reg match\n);\n    typedef enum logic [1:0] {IDLE, CHECK1, CHECK2, DONE} state_t;\n    state_t state, next;\n\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next;\n    end\n\n    always_comb begin\n        case(state)\n            IDLE: next = (in == 8'hAA) ? CHECK1 : IDLE;\n            CHECK1: next = (in == 8'h55) ? CHECK2 : IDLE;\n            CHECK2: next = (in == 8'hFF) ? DONE : IDLE;\n            DONE: next = IDLE;\n        endcase\n    end\n\n    always_comb begin\n        match = (state == DONE);\n    end\nendmodule\n"}
{"code": "module up_counter_4bit_1 (\n    input wire clk,\n    input wire reset,\n    output reg [3:0] count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 4'b0000;\n        else\n            count <= count + 1;\n    end\nendmodule\n"}
{"code": "module down_counter_8bit_1 (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 8'hFF;\n        else\n            count <= count - 1;\n    end\nendmodule\n"}
{"code": "module gray_counter_4bit_1 (\n    input wire clk,\n    input wire reset,\n    output reg [3:0] gray\n);\n    reg [3:0] binary;\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            binary <= 4'b0000;\n            gray <= 4'b0000;\n        end else begin\n            binary <= binary + 1;\n            gray <= binary ^ (binary >> 1);\n        end\n    end\nendmodule\n"}
{"code": "module ring_counter_8bit_1 (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            out <= 8'b00000001;\n        else\n            out <= {out[6:0], out[7]};\n    end\nendmodule\n"}
{"code": "module alu_4bit_1 (\n    input wire [3:0] a, b,\n    input wire [1:0] sel,\n    output reg [3:0] result\n);\n    always @(*) begin\n        case(sel)\n            2'b00: result = a + b;\n            2'b01: result = a - b;\n            2'b10: result = a & b;\n            2'b11: result = a | b;\n        endcase\n    end\nendmodule\n"}
{"code": "module alu_8bit_1 (\n    input wire [7:0] a, b,\n    input wire [2:0] sel,\n    output reg [7:0] result\n);\n    always @(*) begin\n        case(sel)\n            3'b000: result = a + b;\n            3'b001: result = a - b;\n            3'b010: result = a & b;\n            3'b011: result = a | b;\n            3'b100: result = a ^ b;\n            3'b101: result = ~a;\n            3'b110: result = b << 1;\n            3'b111: result = b >> 1;\n        endcase\n    end\nendmodule\n"}
{"code": "module fsm_4bit_seqdet_1 (\n    input wire clk,\n    input wire reset,\n    input wire in,\n    output reg detected\n);\n    typedef enum logic [1:0] {S0, S1, S2, S3} state_t;\n    state_t state, next;\n\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= S0;\n        else\n            state <= next;\n    end\n\n    always_comb begin\n        case (state)\n            S0: next = in ? S1 : S0;\n            S1: next = in ? S1 : S2;\n            S2: next = in ? S3 : S0;\n            S3: next = in ? S1 : S0;\n        endcase\n    end\n\n    always_comb begin\n        detected = (state == S3 && in == 1);\n    end\nendmodule\n"}
{"code": "module fsm_8bit_seqdet_1 (\n    input wire clk,\n    input wire reset,\n    input wire [7:0] in,\n    output reg match\n);\n    typedef enum logic [1:0] {IDLE, CHECK1, CHECK2, DONE} state_t;\n    state_t state, next;\n\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next;\n    end\n\n    always_comb begin\n        case(state)\n            IDLE: next = (in == 8'hAA) ? CHECK1 : IDLE;\n            CHECK1: next = (in == 8'h55) ? CHECK2 : IDLE;\n            CHECK2: next = (in == 8'hFF) ? DONE : IDLE;\n            DONE: next = IDLE;\n        endcase\n    end\n\n    always_comb begin\n        match = (state == DONE);\n    end\nendmodule\n"}
{"code": "module up_counter_4bit_2 (\n    input wire clk,\n    input wire reset,\n    output reg [3:0] count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 4'b0000;\n        else\n            count <= count + 1;\n    end\nendmodule\n"}
{"code": "module down_counter_8bit_2 (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 8'hFF;\n        else\n            count <= count - 1;\n    end\nendmodule\n"}
{"code": "module gray_counter_4bit_2 (\n    input wire clk,\n    input wire reset,\n    output reg [3:0] gray\n);\n    reg [3:0] binary;\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            binary <= 4'b0000;\n            gray <= 4'b0000;\n        end else begin\n            binary <= binary + 1;\n            gray <= binary ^ (binary >> 1);\n        end\n    end\nendmodule\n"}
{"code": "module ring_counter_8bit_2 (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            out <= 8'b00000001;\n        else\n            out <= {out[6:0], out[7]};\n    end\nendmodule\n"}
{"code": "module alu_4bit_2 (\n    input wire [3:0] a, b,\n    input wire [1:0] sel,\n    output reg [3:0] result\n);\n    always @(*) begin\n        case(sel)\n            2'b00: result = a + b;\n            2'b01: result = a - b;\n            2'b10: result = a & b;\n            2'b11: result = a | b;\n        endcase\n    end\nendmodule\n"}
{"code": "module alu_8bit_2 (\n    input wire [7:0] a, b,\n    input wire [2:0] sel,\n    output reg [7:0] result\n);\n    always @(*) begin\n        case(sel)\n            3'b000: result = a + b;\n            3'b001: result = a - b;\n            3'b010: result = a & b;\n            3'b011: result = a | b;\n            3'b100: result = a ^ b;\n            3'b101: result = ~a;\n            3'b110: result = b << 1;\n            3'b111: result = b >> 1;\n        endcase\n    end\nendmodule\n"}
{"code": "module fsm_4bit_seqdet_2 (\n    input wire clk,\n    input wire reset,\n    input wire in,\n    output reg detected\n);\n    typedef enum logic [1:0] {S0, S1, S2, S3} state_t;\n    state_t state, next;\n\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= S0;\n        else\n            state <= next;\n    end\n\n    always_comb begin\n        case (state)\n            S0: next = in ? S1 : S0;\n            S1: next = in ? S1 : S2;\n            S2: next = in ? S3 : S0;\n            S3: next = in ? S1 : S0;\n        endcase\n    end\n\n    always_comb begin\n        detected = (state == S3 && in == 1);\n    end\nendmodule\n"}
{"code": "module fsm_8bit_seqdet_2 (\n    input wire clk,\n    input wire reset,\n    input wire [7:0] in,\n    output reg match\n);\n    typedef enum logic [1:0] {IDLE, CHECK1, CHECK2, DONE} state_t;\n    state_t state, next;\n\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next;\n    end\n\n    always_comb begin\n        case(state)\n            IDLE: next = (in == 8'hAA) ? CHECK1 : IDLE;\n            CHECK1: next = (in == 8'h55) ? CHECK2 : IDLE;\n            CHECK2: next = (in == 8'hFF) ? DONE : IDLE;\n            DONE: next = IDLE;\n        endcase\n    end\n\n    always_comb begin\n        match = (state == DONE);\n    end\nendmodule\n"}
{"code": "module up_counter_4bit_3 (\n    input wire clk,\n    input wire reset,\n    output reg [3:0] count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 4'b0000;\n        else\n            count <= count + 1;\n    end\nendmodule\n"}
{"code": "module down_counter_8bit_3 (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 8'hFF;\n        else\n            count <= count - 1;\n    end\nendmodule\n"}
{"code": "module gray_counter_4bit_3 (\n    input wire clk,\n    input wire reset,\n    output reg [3:0] gray\n);\n    reg [3:0] binary;\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            binary <= 4'b0000;\n            gray <= 4'b0000;\n        end else begin\n            binary <= binary + 1;\n            gray <= binary ^ (binary >> 1);\n        end\n    end\nendmodule\n"}
{"code": "module ring_counter_8bit_3 (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            out <= 8'b00000001;\n        else\n            out <= {out[6:0], out[7]};\n    end\nendmodule\n"}
{"code": "module alu_4bit_3 (\n    input wire [3:0] a, b,\n    input wire [1:0] sel,\n    output reg [3:0] result\n);\n    always @(*) begin\n        case(sel)\n            2'b00: result = a + b;\n            2'b01: result = a - b;\n            2'b10: result = a & b;\n            2'b11: result = a | b;\n        endcase\n    end\nendmodule\n"}
{"code": "module alu_8bit_3 (\n    input wire [7:0] a, b,\n    input wire [2:0] sel,\n    output reg [7:0] result\n);\n    always @(*) begin\n        case(sel)\n            3'b000: result = a + b;\n            3'b001: result = a - b;\n            3'b010: result = a & b;\n            3'b011: result = a | b;\n            3'b100: result = a ^ b;\n            3'b101: result = ~a;\n            3'b110: result = b << 1;\n            3'b111: result = b >> 1;\n        endcase\n    end\nendmodule\n"}
{"code": "module fsm_4bit_seqdet_3 (\n    input wire clk,\n    input wire reset,\n    input wire in,\n    output reg detected\n);\n    typedef enum logic [1:0] {S0, S1, S2, S3} state_t;\n    state_t state, next;\n\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= S0;\n        else\n            state <= next;\n    end\n\n    always_comb begin\n        case (state)\n            S0: next = in ? S1 : S0;\n            S1: next = in ? S1 : S2;\n            S2: next = in ? S3 : S0;\n            S3: next = in ? S1 : S0;\n        endcase\n    end\n\n    always_comb begin\n        detected = (state == S3 && in == 1);\n    end\nendmodule\n"}
{"code": "module fsm_8bit_seqdet_3 (\n    input wire clk,\n    input wire reset,\n    input wire [7:0] in,\n    output reg match\n);\n    typedef enum logic [1:0] {IDLE, CHECK1, CHECK2, DONE} state_t;\n    state_t state, next;\n\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next;\n    end\n\n    always_comb begin\n        case(state)\n            IDLE: next = (in == 8'hAA) ? CHECK1 : IDLE;\n            CHECK1: next = (in == 8'h55) ? CHECK2 : IDLE;\n            CHECK2: next = (in == 8'hFF) ? DONE : IDLE;\n            DONE: next = IDLE;\n        endcase\n    end\n\n    always_comb begin\n        match = (state == DONE);\n    end\nendmodule\n"}
{"code": "module up_counter_4bit_4 (\n    input wire clk,\n    input wire reset,\n    output reg [3:0] count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 4'b0000;\n        else\n            count <= count + 1;\n    end\nendmodule\n"}
{"code": "module down_counter_8bit_4 (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 8'hFF;\n        else\n            count <= count - 1;\n    end\nendmodule\n"}
{"code": "module gray_counter_4bit_4 (\n    input wire clk,\n    input wire reset,\n    output reg [3:0] gray\n);\n    reg [3:0] binary;\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            binary <= 4'b0000;\n            gray <= 4'b0000;\n        end else begin\n            binary <= binary + 1;\n            gray <= binary ^ (binary >> 1);\n        end\n    end\nendmodule\n"}
{"code": "module ring_counter_8bit_4 (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            out <= 8'b00000001;\n        else\n            out <= {out[6:0], out[7]};\n    end\nendmodule\n"}
{"code": "module alu_4bit_4 (\n    input wire [3:0] a, b,\n    input wire [1:0] sel,\n    output reg [3:0] result\n);\n    always @(*) begin\n        case(sel)\n            2'b00: result = a + b;\n            2'b01: result = a - b;\n            2'b10: result = a & b;\n            2'b11: result = a | b;\n        endcase\n    end\nendmodule\n"}
{"code": "module alu_8bit_4 (\n    input wire [7:0] a, b,\n    input wire [2:0] sel,\n    output reg [7:0] result\n);\n    always @(*) begin\n        case(sel)\n            3'b000: result = a + b;\n            3'b001: result = a - b;\n            3'b010: result = a & b;\n            3'b011: result = a | b;\n            3'b100: result = a ^ b;\n            3'b101: result = ~a;\n            3'b110: result = b << 1;\n            3'b111: result = b >> 1;\n        endcase\n    end\nendmodule\n"}
{"code": "module fsm_4bit_seqdet_4 (\n    input wire clk,\n    input wire reset,\n    input wire in,\n    output reg detected\n);\n    typedef enum logic [1:0] {S0, S1, S2, S3} state_t;\n    state_t state, next;\n\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= S0;\n        else\n            state <= next;\n    end\n\n    always_comb begin\n        case (state)\n            S0: next = in ? S1 : S0;\n            S1: next = in ? S1 : S2;\n            S2: next = in ? S3 : S0;\n            S3: next = in ? S1 : S0;\n        endcase\n    end\n\n    always_comb begin\n        detected = (state == S3 && in == 1);\n    end\nendmodule\n"}
{"code": "module fsm_8bit_seqdet_4 (\n    input wire clk,\n    input wire reset,\n    input wire [7:0] in,\n    output reg match\n);\n    typedef enum logic [1:0] {IDLE, CHECK1, CHECK2, DONE} state_t;\n    state_t state, next;\n\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next;\n    end\n\n    always_comb begin\n        case(state)\n            IDLE: next = (in == 8'hAA) ? CHECK1 : IDLE;\n            CHECK1: next = (in == 8'h55) ? CHECK2 : IDLE;\n            CHECK2: next = (in == 8'hFF) ? DONE : IDLE;\n            DONE: next = IDLE;\n        endcase\n    end\n\n    always_comb begin\n        match = (state == DONE);\n    end\nendmodule\n"}
{"code": "module up_counter_4bit_5 (\n    input wire clk,\n    input wire reset,\n    output reg [3:0] count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 4'b0000;\n        else\n            count <= count + 1;\n    end\nendmodule\n"}
{"code": "module down_counter_8bit_5 (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 8'hFF;\n        else\n            count <= count - 1;\n    end\nendmodule\n"}
{"code": "module gray_counter_4bit_5 (\n    input wire clk,\n    input wire reset,\n    output reg [3:0] gray\n);\n    reg [3:0] binary;\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            binary <= 4'b0000;\n            gray <= 4'b0000;\n        end else begin\n            binary <= binary + 1;\n            gray <= binary ^ (binary >> 1);\n        end\n    end\nendmodule\n"}
{"code": "module ring_counter_8bit_5 (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            out <= 8'b00000001;\n        else\n            out <= {out[6:0], out[7]};\n    end\nendmodule\n"}
{"code": "module alu_4bit_5 (\n    input wire [3:0] a, b,\n    input wire [1:0] sel,\n    output reg [3:0] result\n);\n    always @(*) begin\n        case(sel)\n            2'b00: result = a + b;\n            2'b01: result = a - b;\n            2'b10: result = a & b;\n            2'b11: result = a | b;\n        endcase\n    end\nendmodule\n"}
{"code": "module alu_8bit_5 (\n    input wire [7:0] a, b,\n    input wire [2:0] sel,\n    output reg [7:0] result\n);\n    always @(*) begin\n        case(sel)\n            3'b000: result = a + b;\n            3'b001: result = a - b;\n            3'b010: result = a & b;\n            3'b011: result = a | b;\n            3'b100: result = a ^ b;\n            3'b101: result = ~a;\n            3'b110: result = b << 1;\n            3'b111: result = b >> 1;\n        endcase\n    end\nendmodule\n"}
{"code": "module fsm_4bit_seqdet_5 (\n    input wire clk,\n    input wire reset,\n    input wire in,\n    output reg detected\n);\n    typedef enum logic [1:0] {S0, S1, S2, S3} state_t;\n    state_t state, next;\n\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= S0;\n        else\n            state <= next;\n    end\n\n    always_comb begin\n        case (state)\n            S0: next = in ? S1 : S0;\n            S1: next = in ? S1 : S2;\n            S2: next = in ? S3 : S0;\n            S3: next = in ? S1 : S0;\n        endcase\n    end\n\n    always_comb begin\n        detected = (state == S3 && in == 1);\n    end\nendmodule\n"}
{"code": "module fsm_8bit_seqdet_5 (\n    input wire clk,\n    input wire reset,\n    input wire [7:0] in,\n    output reg match\n);\n    typedef enum logic [1:0] {IDLE, CHECK1, CHECK2, DONE} state_t;\n    state_t state, next;\n\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next;\n    end\n\n    always_comb begin\n        case(state)\n            IDLE: next = (in == 8'hAA) ? CHECK1 : IDLE;\n            CHECK1: next = (in == 8'h55) ? CHECK2 : IDLE;\n            CHECK2: next = (in == 8'hFF) ? DONE : IDLE;\n            DONE: next = IDLE;\n        endcase\n    end\n\n    always_comb begin\n        match = (state == DONE);\n    end\nendmodule\n"}
{"code": "module up_counter_4bit_6 (\n    input wire clk,\n    input wire reset,\n    output reg [3:0] count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 4'b0000;\n        else\n            count <= count + 1;\n    end\nendmodule\n"}
{"code": "module down_counter_8bit_6 (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 8'hFF;\n        else\n            count <= count - 1;\n    end\nendmodule\n"}
{"code": "module gray_counter_4bit_6 (\n    input wire clk,\n    input wire reset,\n    output reg [3:0] gray\n);\n    reg [3:0] binary;\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            binary <= 4'b0000;\n            gray <= 4'b0000;\n        end else begin\n            binary <= binary + 1;\n            gray <= binary ^ (binary >> 1);\n        end\n    end\nendmodule\n"}
{"code": "module ring_counter_8bit_6 (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            out <= 8'b00000001;\n        else\n            out <= {out[6:0], out[7]};\n    end\nendmodule\n"}
{"code": "module alu_4bit_6 (\n    input wire [3:0] a, b,\n    input wire [1:0] sel,\n    output reg [3:0] result\n);\n    always @(*) begin\n        case(sel)\n            2'b00: result = a + b;\n            2'b01: result = a - b;\n            2'b10: result = a & b;\n            2'b11: result = a | b;\n        endcase\n    end\nendmodule\n"}
{"code": "module alu_8bit_6 (\n    input wire [7:0] a, b,\n    input wire [2:0] sel,\n    output reg [7:0] result\n);\n    always @(*) begin\n        case(sel)\n            3'b000: result = a + b;\n            3'b001: result = a - b;\n            3'b010: result = a & b;\n            3'b011: result = a | b;\n            3'b100: result = a ^ b;\n            3'b101: result = ~a;\n            3'b110: result = b << 1;\n            3'b111: result = b >> 1;\n        endcase\n    end\nendmodule\n"}
{"code": "module fsm_4bit_seqdet_6 (\n    input wire clk,\n    input wire reset,\n    input wire in,\n    output reg detected\n);\n    typedef enum logic [1:0] {S0, S1, S2, S3} state_t;\n    state_t state, next;\n\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= S0;\n        else\n            state <= next;\n    end\n\n    always_comb begin\n        case (state)\n            S0: next = in ? S1 : S0;\n            S1: next = in ? S1 : S2;\n            S2: next = in ? S3 : S0;\n            S3: next = in ? S1 : S0;\n        endcase\n    end\n\n    always_comb begin\n        detected = (state == S3 && in == 1);\n    end\nendmodule\n"}
{"code": "module fsm_8bit_seqdet_6 (\n    input wire clk,\n    input wire reset,\n    input wire [7:0] in,\n    output reg match\n);\n    typedef enum logic [1:0] {IDLE, CHECK1, CHECK2, DONE} state_t;\n    state_t state, next;\n\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next;\n    end\n\n    always_comb begin\n        case(state)\n            IDLE: next = (in == 8'hAA) ? CHECK1 : IDLE;\n            CHECK1: next = (in == 8'h55) ? CHECK2 : IDLE;\n            CHECK2: next = (in == 8'hFF) ? DONE : IDLE;\n            DONE: next = IDLE;\n        endcase\n    end\n\n    always_comb begin\n        match = (state == DONE);\n    end\nendmodule\n"}
{"code": "module up_counter_4bit_7 (\n    input wire clk,\n    input wire reset,\n    output reg [3:0] count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 4'b0000;\n        else\n            count <= count + 1;\n    end\nendmodule\n"}
{"code": "module down_counter_8bit_7 (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 8'hFF;\n        else\n            count <= count - 1;\n    end\nendmodule\n"}
{"code": "module gray_counter_4bit_7 (\n    input wire clk,\n    input wire reset,\n    output reg [3:0] gray\n);\n    reg [3:0] binary;\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            binary <= 4'b0000;\n            gray <= 4'b0000;\n        end else begin\n            binary <= binary + 1;\n            gray <= binary ^ (binary >> 1);\n        end\n    end\nendmodule\n"}
{"code": "module ring_counter_8bit_7 (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            out <= 8'b00000001;\n        else\n            out <= {out[6:0], out[7]};\n    end\nendmodule\n"}
{"code": "module alu_4bit_7 (\n    input wire [3:0] a, b,\n    input wire [1:0] sel,\n    output reg [3:0] result\n);\n    always @(*) begin\n        case(sel)\n            2'b00: result = a + b;\n            2'b01: result = a - b;\n            2'b10: result = a & b;\n            2'b11: result = a | b;\n        endcase\n    end\nendmodule\n"}
{"code": "module alu_8bit_7 (\n    input wire [7:0] a, b,\n    input wire [2:0] sel,\n    output reg [7:0] result\n);\n    always @(*) begin\n        case(sel)\n            3'b000: result = a + b;\n            3'b001: result = a - b;\n            3'b010: result = a & b;\n            3'b011: result = a | b;\n            3'b100: result = a ^ b;\n            3'b101: result = ~a;\n            3'b110: result = b << 1;\n            3'b111: result = b >> 1;\n        endcase\n    end\nendmodule\n"}
{"code": "module fsm_4bit_seqdet_7 (\n    input wire clk,\n    input wire reset,\n    input wire in,\n    output reg detected\n);\n    typedef enum logic [1:0] {S0, S1, S2, S3} state_t;\n    state_t state, next;\n\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= S0;\n        else\n            state <= next;\n    end\n\n    always_comb begin\n        case (state)\n            S0: next = in ? S1 : S0;\n            S1: next = in ? S1 : S2;\n            S2: next = in ? S3 : S0;\n            S3: next = in ? S1 : S0;\n        endcase\n    end\n\n    always_comb begin\n        detected = (state == S3 && in == 1);\n    end\nendmodule\n"}
{"code": "module fsm_8bit_seqdet_7 (\n    input wire clk,\n    input wire reset,\n    input wire [7:0] in,\n    output reg match\n);\n    typedef enum logic [1:0] {IDLE, CHECK1, CHECK2, DONE} state_t;\n    state_t state, next;\n\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next;\n    end\n\n    always_comb begin\n        case(state)\n            IDLE: next = (in == 8'hAA) ? CHECK1 : IDLE;\n            CHECK1: next = (in == 8'h55) ? CHECK2 : IDLE;\n            CHECK2: next = (in == 8'hFF) ? DONE : IDLE;\n            DONE: next = IDLE;\n        endcase\n    end\n\n    always_comb begin\n        match = (state == DONE);\n    end\nendmodule\n"}
{"code": "module up_counter_4bit_8 (\n    input wire clk,\n    input wire reset,\n    output reg [3:0] count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 4'b0000;\n        else\n            count <= count + 1;\n    end\nendmodule\n"}
{"code": "module down_counter_8bit_8 (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 8'hFF;\n        else\n            count <= count - 1;\n    end\nendmodule\n"}
{"code": "module gray_counter_4bit_8 (\n    input wire clk,\n    input wire reset,\n    output reg [3:0] gray\n);\n    reg [3:0] binary;\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            binary <= 4'b0000;\n            gray <= 4'b0000;\n        end else begin\n            binary <= binary + 1;\n            gray <= binary ^ (binary >> 1);\n        end\n    end\nendmodule\n"}
{"code": "module ring_counter_8bit_8 (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            out <= 8'b00000001;\n        else\n            out <= {out[6:0], out[7]};\n    end\nendmodule\n"}
{"code": "module alu_4bit_8 (\n    input wire [3:0] a, b,\n    input wire [1:0] sel,\n    output reg [3:0] result\n);\n    always @(*) begin\n        case(sel)\n            2'b00: result = a + b;\n            2'b01: result = a - b;\n            2'b10: result = a & b;\n            2'b11: result = a | b;\n        endcase\n    end\nendmodule\n"}
{"code": "module alu_8bit_8 (\n    input wire [7:0] a, b,\n    input wire [2:0] sel,\n    output reg [7:0] result\n);\n    always @(*) begin\n        case(sel)\n            3'b000: result = a + b;\n            3'b001: result = a - b;\n            3'b010: result = a & b;\n            3'b011: result = a | b;\n            3'b100: result = a ^ b;\n            3'b101: result = ~a;\n            3'b110: result = b << 1;\n            3'b111: result = b >> 1;\n        endcase\n    end\nendmodule\n"}
{"code": "module fsm_4bit_seqdet_8 (\n    input wire clk,\n    input wire reset,\n    input wire in,\n    output reg detected\n);\n    typedef enum logic [1:0] {S0, S1, S2, S3} state_t;\n    state_t state, next;\n\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= S0;\n        else\n            state <= next;\n    end\n\n    always_comb begin\n        case (state)\n            S0: next = in ? S1 : S0;\n            S1: next = in ? S1 : S2;\n            S2: next = in ? S3 : S0;\n            S3: next = in ? S1 : S0;\n        endcase\n    end\n\n    always_comb begin\n        detected = (state == S3 && in == 1);\n    end\nendmodule\n"}
{"code": "module fsm_8bit_seqdet_8 (\n    input wire clk,\n    input wire reset,\n    input wire [7:0] in,\n    output reg match\n);\n    typedef enum logic [1:0] {IDLE, CHECK1, CHECK2, DONE} state_t;\n    state_t state, next;\n\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next;\n    end\n\n    always_comb begin\n        case(state)\n            IDLE: next = (in == 8'hAA) ? CHECK1 : IDLE;\n            CHECK1: next = (in == 8'h55) ? CHECK2 : IDLE;\n            CHECK2: next = (in == 8'hFF) ? DONE : IDLE;\n            DONE: next = IDLE;\n        endcase\n    end\n\n    always_comb begin\n        match = (state == DONE);\n    end\nendmodule\n"}
{"code": "module up_counter_4bit_9 (\n    input wire clk,\n    input wire reset,\n    output reg [3:0] count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 4'b0000;\n        else\n            count <= count + 1;\n    end\nendmodule\n"}
{"code": "module down_counter_8bit_9 (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 8'hFF;\n        else\n            count <= count - 1;\n    end\nendmodule\n"}
{"code": "module gray_counter_4bit_9 (\n    input wire clk,\n    input wire reset,\n    output reg [3:0] gray\n);\n    reg [3:0] binary;\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            binary <= 4'b0000;\n            gray <= 4'b0000;\n        end else begin\n            binary <= binary + 1;\n            gray <= binary ^ (binary >> 1);\n        end\n    end\nendmodule\n"}
{"code": "module ring_counter_8bit_9 (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            out <= 8'b00000001;\n        else\n            out <= {out[6:0], out[7]};\n    end\nendmodule\n"}
{"code": "module alu_4bit_9 (\n    input wire [3:0] a, b,\n    input wire [1:0] sel,\n    output reg [3:0] result\n);\n    always @(*) begin\n        case(sel)\n            2'b00: result = a + b;\n            2'b01: result = a - b;\n            2'b10: result = a & b;\n            2'b11: result = a | b;\n        endcase\n    end\nendmodule\n"}
{"code": "module alu_8bit_9 (\n    input wire [7:0] a, b,\n    input wire [2:0] sel,\n    output reg [7:0] result\n);\n    always @(*) begin\n        case(sel)\n            3'b000: result = a + b;\n            3'b001: result = a - b;\n            3'b010: result = a & b;\n            3'b011: result = a | b;\n            3'b100: result = a ^ b;\n            3'b101: result = ~a;\n            3'b110: result = b << 1;\n            3'b111: result = b >> 1;\n        endcase\n    end\nendmodule\n"}
{"code": "module fsm_4bit_seqdet_9 (\n    input wire clk,\n    input wire reset,\n    input wire in,\n    output reg detected\n);\n    typedef enum logic [1:0] {S0, S1, S2, S3} state_t;\n    state_t state, next;\n\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= S0;\n        else\n            state <= next;\n    end\n\n    always_comb begin\n        case (state)\n            S0: next = in ? S1 : S0;\n            S1: next = in ? S1 : S2;\n            S2: next = in ? S3 : S0;\n            S3: next = in ? S1 : S0;\n        endcase\n    end\n\n    always_comb begin\n        detected = (state == S3 && in == 1);\n    end\nendmodule\n"}
{"code": "module fsm_8bit_seqdet_9 (\n    input wire clk,\n    input wire reset,\n    input wire [7:0] in,\n    output reg match\n);\n    typedef enum logic [1:0] {IDLE, CHECK1, CHECK2, DONE} state_t;\n    state_t state, next;\n\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next;\n    end\n\n    always_comb begin\n        case(state)\n            IDLE: next = (in == 8'hAA) ? CHECK1 : IDLE;\n            CHECK1: next = (in == 8'h55) ? CHECK2 : IDLE;\n            CHECK2: next = (in == 8'hFF) ? DONE : IDLE;\n            DONE: next = IDLE;\n        endcase\n    end\n\n    always_comb begin\n        match = (state == DONE);\n    end\nendmodule\n"}
{"code": "module up_counter_4bit_10 (\n    input wire clk,\n    input wire reset,\n    output reg [3:0] count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 4'b0000;\n        else\n            count <= count + 1;\n    end\nendmodule\n"}
{"code": "module down_counter_8bit_10 (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 8'hFF;\n        else\n            count <= count - 1;\n    end\nendmodule\n"}
{"code": "module gray_counter_4bit_10 (\n    input wire clk,\n    input wire reset,\n    output reg [3:0] gray\n);\n    reg [3:0] binary;\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            binary <= 4'b0000;\n            gray <= 4'b0000;\n        end else begin\n            binary <= binary + 1;\n            gray <= binary ^ (binary >> 1);\n        end\n    end\nendmodule\n"}
{"code": "module ring_counter_8bit_10 (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            out <= 8'b00000001;\n        else\n            out <= {out[6:0], out[7]};\n    end\nendmodule\n"}
{"code": "module alu_4bit_10 (\n    input wire [3:0] a, b,\n    input wire [1:0] sel,\n    output reg [3:0] result\n);\n    always @(*) begin\n        case(sel)\n            2'b00: result = a + b;\n            2'b01: result = a - b;\n            2'b10: result = a & b;\n            2'b11: result = a | b;\n        endcase\n    end\nendmodule\n"}
{"code": "module alu_8bit_10 (\n    input wire [7:0] a, b,\n    input wire [2:0] sel,\n    output reg [7:0] result\n);\n    always @(*) begin\n        case(sel)\n            3'b000: result = a + b;\n            3'b001: result = a - b;\n            3'b010: result = a & b;\n            3'b011: result = a | b;\n            3'b100: result = a ^ b;\n            3'b101: result = ~a;\n            3'b110: result = b << 1;\n            3'b111: result = b >> 1;\n        endcase\n    end\nendmodule\n"}
{"code": "module fsm_4bit_seqdet_10 (\n    input wire clk,\n    input wire reset,\n    input wire in,\n    output reg detected\n);\n    typedef enum logic [1:0] {S0, S1, S2, S3} state_t;\n    state_t state, next;\n\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= S0;\n        else\n            state <= next;\n    end\n\n    always_comb begin\n        case (state)\n            S0: next = in ? S1 : S0;\n            S1: next = in ? S1 : S2;\n            S2: next = in ? S3 : S0;\n            S3: next = in ? S1 : S0;\n        endcase\n    end\n\n    always_comb begin\n        detected = (state == S3 && in == 1);\n    end\nendmodule\n"}
{"code": "module fsm_8bit_seqdet_10 (\n    input wire clk,\n    input wire reset,\n    input wire [7:0] in,\n    output reg match\n);\n    typedef enum logic [1:0] {IDLE, CHECK1, CHECK2, DONE} state_t;\n    state_t state, next;\n\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next;\n    end\n\n    always_comb begin\n        case(state)\n            IDLE: next = (in == 8'hAA) ? CHECK1 : IDLE;\n            CHECK1: next = (in == 8'h55) ? CHECK2 : IDLE;\n            CHECK2: next = (in == 8'hFF) ? DONE : IDLE;\n            DONE: next = IDLE;\n        endcase\n    end\n\n    always_comb begin\n        match = (state == DONE);\n    end\nendmodule\n"}
{"code": "module up_counter_4bit_11 (\n    input wire clk,\n    input wire reset,\n    output reg [3:0] count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 4'b0000;\n        else\n            count <= count + 1;\n    end\nendmodule\n"}
{"code": "module down_counter_8bit_11 (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 8'hFF;\n        else\n            count <= count - 1;\n    end\nendmodule\n"}
{"code": "module gray_counter_4bit_11 (\n    input wire clk,\n    input wire reset,\n    output reg [3:0] gray\n);\n    reg [3:0] binary;\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            binary <= 4'b0000;\n            gray <= 4'b0000;\n        end else begin\n            binary <= binary + 1;\n            gray <= binary ^ (binary >> 1);\n        end\n    end\nendmodule\n"}
{"code": "module ring_counter_8bit_11 (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            out <= 8'b00000001;\n        else\n            out <= {out[6:0], out[7]};\n    end\nendmodule\n"}
{"code": "module alu_4bit_11 (\n    input wire [3:0] a, b,\n    input wire [1:0] sel,\n    output reg [3:0] result\n);\n    always @(*) begin\n        case(sel)\n            2'b00: result = a + b;\n            2'b01: result = a - b;\n            2'b10: result = a & b;\n            2'b11: result = a | b;\n        endcase\n    end\nendmodule\n"}
{"code": "module alu_8bit_11 (\n    input wire [7:0] a, b,\n    input wire [2:0] sel,\n    output reg [7:0] result\n);\n    always @(*) begin\n        case(sel)\n            3'b000: result = a + b;\n            3'b001: result = a - b;\n            3'b010: result = a & b;\n            3'b011: result = a | b;\n            3'b100: result = a ^ b;\n            3'b101: result = ~a;\n            3'b110: result = b << 1;\n            3'b111: result = b >> 1;\n        endcase\n    end\nendmodule\n"}
{"code": "module fsm_4bit_seqdet_11 (\n    input wire clk,\n    input wire reset,\n    input wire in,\n    output reg detected\n);\n    typedef enum logic [1:0] {S0, S1, S2, S3} state_t;\n    state_t state, next;\n\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= S0;\n        else\n            state <= next;\n    end\n\n    always_comb begin\n        case (state)\n            S0: next = in ? S1 : S0;\n            S1: next = in ? S1 : S2;\n            S2: next = in ? S3 : S0;\n            S3: next = in ? S1 : S0;\n        endcase\n    end\n\n    always_comb begin\n        detected = (state == S3 && in == 1);\n    end\nendmodule\n"}
{"code": "module fsm_8bit_seqdet_11 (\n    input wire clk,\n    input wire reset,\n    input wire [7:0] in,\n    output reg match\n);\n    typedef enum logic [1:0] {IDLE, CHECK1, CHECK2, DONE} state_t;\n    state_t state, next;\n\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next;\n    end\n\n    always_comb begin\n        case(state)\n            IDLE: next = (in == 8'hAA) ? CHECK1 : IDLE;\n            CHECK1: next = (in == 8'h55) ? CHECK2 : IDLE;\n            CHECK2: next = (in == 8'hFF) ? DONE : IDLE;\n            DONE: next = IDLE;\n        endcase\n    end\n\n    always_comb begin\n        match = (state == DONE);\n    end\nendmodule\n"}
{"code": "module up_counter_4bit_12 (\n    input wire clk,\n    input wire reset,\n    output reg [3:0] count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 4'b0000;\n        else\n            count <= count + 1;\n    end\nendmodule\n"}
{"code": "module down_counter_8bit_12 (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 8'hFF;\n        else\n            count <= count - 1;\n    end\nendmodule\n"}
{"code": "module gray_counter_4bit_12 (\n    input wire clk,\n    input wire reset,\n    output reg [3:0] gray\n);\n    reg [3:0] binary;\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            binary <= 4'b0000;\n            gray <= 4'b0000;\n        end else begin\n            binary <= binary + 1;\n            gray <= binary ^ (binary >> 1);\n        end\n    end\nendmodule\n"}
{"code": "module ring_counter_8bit_12 (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            out <= 8'b00000001;\n        else\n            out <= {out[6:0], out[7]};\n    end\nendmodule\n"}
